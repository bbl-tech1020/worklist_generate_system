{% extends 'dashboard/index.html' %}
{% load static %}

{% block header %}
<header class="navbar navbar-expand-md navbar-light d-print-none">
    <div class="container-fluid">
        <h1 class="navbar-brand">文件替换</h1>
    </div>
    {% include "dashboard/partials/user_toolbar.html" %}
</header>
{% endblock %}

{% block content %}
<style>
    .replace-title {
        font-weight: 700;
        margin: 12px 0 10px;
    }

    .hint {
        color: #6c757d;
        font-size: 13px;
        margin-top: 6px;
    }

    .barcode-input {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        letter-spacing: .2px;
    }

    .readonly-pill {
        background: #f6f7f9;
    }

    .op-btns {
        display: inline-flex;
        gap: 8px;
    }

    /* ===== 表头美化 ===== */
    .used-table thead th,
    .nouse-table thead th,
    .delete-table thead th {
        font-size: 16px;
        /* 表头字体变大 */
        font-weight: 700;
        text-align: center;
        /* 水平居中 */
        vertical-align: middle;
        /* 垂直居中 */
        padding: 12px 8px;
    }

    /* ===== 表体输入框美化 ===== */
    .used-table tbody td,
    .nouse-table tbody td,
    .delete-table tbody td {
        vertical-align: middle;
    }

    .used-table input.form-control,
    .nouse-table input.form-control,
    .delete-table input.form-control {
        height: 40px;
        /* 输入框高度 */
        font-size: 15px;
        padding: 8px 10px;
    }

    /* 只读孔位样式更“禁用感”一点 */
    .used-table input[readonly] {
        background-color: #f5f6f8;
        color: #555;
    }

    /* ===== 操作按钮（添加 / 删除）放大 ===== */
    .used-table .btn,
    .nouse-table .btn,
    .delete-table .btn {
        font-size: 14px;
        padding: 6px 14px;
        min-width: 64px;
    }

    /* 操作列居中 */
    .used-table td:last-child,
    .nouse-table td:last-child,
    .delete-table td:last-child {
        text-align: center;
    }

    /* ===== 提交按钮区域 ===== */
    .submit-bar {
        display: flex;
        justify-content: flex-start;
        /* 提交按钮靠左 */
        margin-top: 16px;
    }

    /* 当前条码未匹配：孔位框标红 + 提示文字 */
    .vialpos-invalid {
        border-color: #dc3545 !important;
        background-color: #fff5f5;
    }

    .vialpos-hint {
        font-size: 12px;
        margin-top: 4px;
        color: #dc3545;
        display: none;
    }

    .vialpos-hint.show {
        display: block;
    }

    /* nouse 即时提示：通过/不通过两种颜色 */
    .vialpos-hint.ok {
        color: #198754;
    }

    .vialpos-hint.err {
        color: #dc3545;
    }

    /* 未用孔位集合摘要展示 */
    .unused-summary {
        margin-top: 8px;
        font-size: 13px;
        color: #6c757d;
        word-break: break-all;
    }
</style>

<form method="post" enctype="multipart/form-data" id="replace-form">
    {% csrf_token %}

    <div class="card mt-4">
        <div class="card-body">

            <div class="mb-3">
                <label class="form-label">替换文件</label>
                <!-- ✅ 补上 id，后续你写联动逻辑会更方便 -->
                <input type="file" class="form-control" id="replace_file" name="replace_file">
                <div class="hint">请上传需要替换的上机列表文件(必须与‘文件下载’页面中已存在的任一上机列表文件名相同)</div>

                <!-- ✅ 新增：文件名校验提示 -->
                <div id="filename-check-msg" class="hint" style="display:none;"></div>
            </div>

            <div class="mb-3">
                <label class="form-label">替换操作</label>
                <select class="form-select" id="replace_reason" name="replace_reason" required>
                    <option value="">请选择替换操作</option>
                    <option value="used">已用孔位替换（如扫错条码）</option>
                    <option value="nouse">未用孔位替换（如样本量不足，存在剩余孔位）</option>
                    <option value="delete">孔位删除</option>
                    <option value="custom">自定义（可组合多个功能）</option>
                </select>
                <input type="hidden" id="project-name" name="project_name">
            </div>


            <!-- ✅ 新增：自定义功能选择区域 -->
            <div id="custom-selector-panel" style="display:none;">
                <div class="card mb-3">
                    <div class="card-body">
                        <label class="form-label fw-bold">请选择要使用的功能模块：</label>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="custom-used" value="used">
                            <label class="form-check-label" for="custom-used">
                                已用孔位替换
                            </label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="custom-nouse" value="nouse">
                            <label class="form-check-label" for="custom-nouse">
                                未用孔位替换
                            </label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="custom-delete" value="delete">
                            <label class="form-check-label" for="custom-delete">
                                孔位删除
                            </label>
                        </div>
                        <div class="hint mt-2" style="color: #dc3545;">
                            至少选择一个功能模块
                        </div>
                    </div>
                </div>
            </div>


            <!-- ✅ 已用孔位替换区域：先只做展示与添加行，不写孔位关联逻辑 -->
            <div id="used-panel" style="display:none;">
                <div class="replace-title">已用孔位替换</div>

                <div class="table-responsive">
                    <table class="table table-sm table-bordered align-middle used-table">
                        <thead class="table-light">
                            <tr>
                                <th style="width: 16%;">孔位（VialPos）</th>
                                <th style="width: 34%;">当前条码或实验号</th>
                                <th style="width: 34%;">新条码或实验号</th>
                                <th style="width: 16%;">操作</th>
                            </tr>
                        </thead>
                        <tbody id="used-tbody">
                            <!-- 行由 JS 动态生成 -->
                        </tbody>
                    </table>
                </div>

                <div class="hint">说明1：上传的替换文件的文件名必须与‘文件下载’页面中已存在的任意一个上机列表的文件名相同</div>
                <div class="hint">说明2：当前条码或实验号的匹配规则：精确匹配（必须输入完整条码或实验号，不能只输入主条码，但不区分大小写）</div>
                <div class="hint">说明3：用于替换的新条码或实验号，不能与当天已生成的任一条码或实验号一致</div>
                <div class="hint">说明4：替换时，只会替换上机列表中的第一列的内容。其余列内容不替换（针对IGF-1项目，第6列内容与第1列内容完全相同，也会同步进行替换）</div>
                <div class="hint">说明5：替换后的新文件会取代‘文件下载’页面中的旧文件，旧文件会移动到‘历史文件’路径下，需在‘文件下载’页面点击‘历史文件’查阅</div>
            </div>

            <!-- ✅ 未用孔位替换区域（nouse） -->
            <div id="nouse-panel" style="display:none;">
                <div class="replace-title">未用孔位替换</div>

                <div class="table-responsive">
                    <table class="table table-sm table-bordered align-middle nouse-table">
                        <thead class="table-light">
                            <tr>
                                <th style="width: 30%;">孔位（VialPos）</th>
                                <th style="width: 40%;">新条码或实验号</th>
                                <th style="width: 30%;">操作</th>
                            </tr>
                        </thead>
                        <tbody id="nouse-tbody">
                            <!-- 行由 JS 动态生成 -->
                        </tbody>
                    </table>
                </div>

                <div id="unused-summary" class="unused-summary" style="display:none;"></div>

                <div class="hint">未用孔位的识别逻辑：</div>
                <div class="hint">1 NIMBUS的逻辑：孔位列中未在1-96或A1-H12中出现的孔位，或者第一列内容为‘NOTUBE’的孔位</div>
                <div class="hint">2 Starlet的逻辑：孔位列中未在1-96或A1-H12中出现的孔位，或者第一列内容为‘NOTUBE’的孔位</div>
                <div class="hint">3 Tecan的逻辑：</div>
                <div class="hint">3.1 起始列为第1列：孔位列中未在1-96或A1-H12中出现的孔位，或者第一列内容为‘’的孔位</div>
                <div class="hint">3.2 起始列为第N列：孔位列中未在N-96或AN-H12中出现的孔位，或者第一列内容为‘’的孔位(起始列的识别逻辑：抓取孔位列中最小的数字)</div>
                <div class="hint">4 未用孔位替换时，不止替换第一列的内容，其余列的内容也会进行替换</div>
                <div class="hint">5 比对样和稀释样的命名规则</div>

            </div>

            <!-- ✅ 孔位删除区域 -->
            <div id="delete-panel" style="display:none;">
                <div class="replace-title">孔位删除</div>

                <div class="table-responsive">
                    <table class="table table-sm table-bordered align-middle delete-table">
                        <thead class="table-light">
                            <tr>
                                <th style="width: 30%;">孔位（VIALPOS）</th>
                                <th style="width: 55%;">条码或实验号</th>
                                <th style="width: 15%;">操作</th>
                            </tr>
                        </thead>
                        <tbody id="delete-tbody"></tbody>
                    </table>
                </div>

                <div class="hint">
                    说明：孔位或条码/实验号二选一输入即可，另一列会自动匹配；输入内容必须存在于已上传的上机列表中。
                </div>
            </div>


            <div class="mt-3 submit-bar">
                <div id="sampled-conflict-summary" class="alert alert-warning"
                    style="display:none; margin: 0 0 10px 0;"></div>
                <button type="submit" class="btn btn-primary" id="submit-btn">提交</button>
            </div>

        </div>
    </div>

</form>

<!-- 把后端传来的文件名列表注入到页面 -->
{{ onboarding_filenames|json_script:"onboarding-filenames" }}

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // ===== 全局阻止输入框回车键触发表单提交 =====
        const replaceForm = document.getElementById('replace-form');

        // 在表单级别拦截所有输入框的回车键
        replaceForm.addEventListener('keydown', (e) => {
            // 如果按的是回车键，且当前聚焦元素是输入框（不是提交按钮）
            if (e.key === 'Enter' && e.target.tagName === 'INPUT' && e.target.type !== 'submit') {
                e.preventDefault(); // 阻止默认的表单提交行为
                e.stopPropagation(); // 阻止事件冒泡
                return false;
            }
        });

        // 解析用户上传的上机列表
        const replaceFileInput = document.getElementById('replace_file');

        // ✅ 读入后端传来的“文件下载页已有 OnboardingList 文件名列表”
        const existingNames = new Set(
            JSON.parse(document.getElementById('onboarding-filenames').textContent || '[]')
        );

        // 控件引用
        const msgEl = document.getElementById('filename-check-msg');
        const submitBtn = document.getElementById('submit-btn');

        let stationDate = '';
        const projectNameInput = document.getElementById('project-name');

        function extractProjectFromFilename(fname) {
            // 匹配：_S2_25OHD_20260108_
            const m = (fname || '').match(/_S\d+_([A-Za-z0-9]+)_(\d{8})_/);
            return m ? (m[1] || '').trim() : '';
        }

        // station lookup cache（避免频繁请求）
        const stationCache = new Map();

        // ✅ 统一控制：是否允许后续操作
        function setAllowed(ok, message, isError = true) {
            // 提示
            if (message) {
                msgEl.style.display = 'block';
                msgEl.textContent = message;
                msgEl.style.color = isError ? '#dc3545' : '#198754'; // 红/绿
            } else {
                msgEl.style.display = 'none';
            }

            // 禁用/启用替换类型选择 + 提交按钮
            replaceReasonSelect.disabled = !ok;
            baseAllowed = !!ok;
            updateSubmitState();

            // 不允许时：隐藏面板、清空表格，避免“继续填了再提交”
            if (!ok) {
                usedPanel.style.display = 'none';
                nousePanel.style.display = 'none';
                replaceReasonSelect.value = '';
                usedTbody.innerHTML = '';
                nouseTbody.innerHTML = '';
            }
        }


        // ===== 提交按钮统一校验：只要任一可见校验不通过，则禁止提交 =====
        let baseAllowed = false; // 仅代表“文件名校验通过”，不代表整表可提交

        function isElementVisible(el) {
            return !!(el && el.offsetParent !== null);
        }

        function isInVisiblePanel(el) {
            const panel = el.closest('#used-panel, #nouse-panel, #delete-panel');
            if (!panel) return true;
            return panel.style.display !== 'none';
        }

        function updateSubmitState() {
            // 必须：文件名校验通过 + 文件解析成功 + 已选择替换操作
            if (!baseAllowed || !parsedOK || !replaceReasonSelect.value) {
                submitBtn.disabled = true;
                return;
            }

            // ✅ 新增：自定义模式下，必须至少选择一个功能模块
            if (replaceReasonSelect.value === 'custom') {
                const hasSelection = customUsedCheckbox.checked ||
                    customNouseCheckbox.checked ||
                    customDeleteCheckbox.checked;
                if (!hasSelection) {
                    submitBtn.disabled = true;
                    return;
                }
            }

            // 1) 任一输入框处于“invalid”状态（红框）-> 禁止提交
            const invalidInputs = Array.from(document.querySelectorAll('#replace-form .vialpos-invalid'))
                .filter(el => isElementVisible(el) && isInVisiblePanel(el));
            if (invalidInputs.length > 0) {
                submitBtn.disabled = true;
                return;
            }

            // 2) 任一“新条码/实验号重复确认条”仍在显示（未确认）-> 禁止提交
            const pendingConfirm = Array.from(document.querySelectorAll('#replace-form .new-code-hint'))
                .filter(el => isElementVisible(el) && isInVisiblePanel(el) && (el.style.display !== 'none'));
            if (pendingConfirm.length > 0) {
                submitBtn.disabled = true;
                return;
            }

            submitBtn.disabled = false;
        }

        // 条码 -> 孔位 的映射表
        let barcodeToVialPos = new Map();
        let vialPosToBarcode = new Map(); // ✅ 新增：孔位 -> 条码/实验号

        // ✅ 新增：实验号 -> 条码 的映射表
        let sampleToBarcode = new Map();

        let parsedOK = false;

        // ===== 未用孔位集合（用于 nouse 即时提示）=====
        let unusedVialPosKeys = new Set();   // 存 key：A1 / "1" 这种，方便快速判断
        let unusedVialPosShow = [];          // 存展示用：A1(1)、B3(15)...

        // ===== 新增: 未用孔位映射表(孔位 -> 条码信息) =====
        let unusedVialPosMap = new Map()
        const unusedSummaryEl = document.getElementById('unused-summary');

        // 识别分隔符：逗号/制表符/分号（你们文件有时是 \t）
        function guessDelimiter(line) {
            const tab = (line.match(/\t/g) || []).length;
            const comma = (line.match(/,/g) || []).length;
            const semi = (line.match(/;/g) || []).length;
            if (tab >= comma && tab >= semi) return '\t';
            if (comma >= semi) return ',';
            return ';';
        }

        // 表头容错：比如第一格是 "% header=SampleName"
        function normalizeHeader(h) {
            return (h || '')
                .replace(/^%?\s*header\s*=\s*/i, '')
                .trim()
                .toLowerCase();
        }

        // 孔位清洗：如果含进样盘号，只取“最后一段”
        // 例： "1-20004" / "1:20004" / "Rack1 20004" -> "20004"
        function cleanVialPos(raw) {
            const s = (raw || '').trim();
            if (!s) return '';
            // 按常见分隔符切
            const parts = s.split(/[\s:\-_]+/).filter(Boolean);
            return parts.length ? parts[parts.length - 1] : s;
        }


        function wellToNum(well) {
            const s = (well || '').trim().toUpperCase();
            const m = s.match(/^([A-H])\s*([1-9]|1[0-2])$/);
            if (!m) return null;
            const rowIdx = m[1].charCodeAt(0) - 'A'.charCodeAt(0); // 0..7
            const col = Number(m[2]); // 1..12
            return rowIdx * 12 + col; // 1..96
        }


        // 用户输入可能是 "A1" / "a1" / "1" / " 01 "，归一化为 {num, well, ok}
        function normalizeUserVialPosInput(input) {
            let raw = (input || '').trim();
            if (!raw) return { ok: false };

            // 统一括号 + 统一大小写
            raw = raw.replace(/（/g, '(').replace(/）/g, ')').toUpperCase();

            // 允许形如 A1(1) / 1(1) 的输入：提取括号里的数字并做一致性校验
            let parenNum = null;
            const pm = raw.match(/^(.*)\(\s*(\d+)\s*\)\s*$/);
            if (pm) {
                raw = (pm[1] || '').trim();
                parenNum = Number(pm[2]);
                if (!Number.isFinite(parenNum)) return { ok: false };
            }

            // 纯数字：1~96（允许输入 1 或 01）
            if (/^\d+$/.test(raw)) {
                const n = Number(raw);
                const well = numToWell(n);
                if (!well) return { ok: false };
                // 如果用户输入了括号数字，则要求括号数字与孔位数字一致
                if (parenNum !== null && parenNum !== n) return { ok: false };
                return { ok: true, num: n, well, kind: 'num' };
            }

            // A1~H12（不区分大小写）
            const n = wellToNum(raw);
            if (!n) return { ok: false };
            if (parenNum !== null && parenNum !== n) return { ok: false };
            return { ok: true, num: n, well: numToWell(n), kind: 'well' };
        }

        // ====== 96孔位工具：1~96 <-> A1~H12 ======
        function numToWell(num) {
            const n = parseInt(num, 10);
            if (!Number.isFinite(n) || n < 1 || n > 96) return '';
            const row = String.fromCharCode('A'.charCodeAt(0) + Math.floor((n - 1) / 12));
            const col = ((n - 1) % 12) + 1;
            return `${row}${col}`;
        }


        function formatVialPosDisplay(nOrWellOrRaw) {
            // 输入可以是数值、A1、或清洗后的 raw（如 "1" / "A1"）
            const raw = (nOrWellOrRaw ?? '').toString().trim();
            if (!raw) return '';
            const norm = normalizeUserVialPosInput(raw);
            if (norm.ok) return `${norm.well}(${norm.num})`; // ✅ A1(1) 形式
            // 如果 raw 不是标准形式，原样返回（兜底）
            return raw;
        }

        // 解析文件：第一列为条码列；孔位列名可能是 VialPos / Vial position
        function parseOnboardingText(text) {
            const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
            if (lines.length < 2) return { ok: false, msg: '文件内容不足，无法解析。' };

            const delimiter = guessDelimiter(lines[0]);
            const rawHeaders = lines[0].split(delimiter);
            const headers = rawHeaders.map(normalizeHeader);

            // ✅ 添加调试输出
            console.log('=== 调试信息 ===');
            console.log('原始表头:', rawHeaders);
            console.log('归一化后表头:', headers);
            console.log('分隔符:', delimiter === '\t' ? 'TAB' : delimiter);

            // 条码列：需求说“第一列”，所以默认 index=0
            // 但为了稳，也允许识别 sample/samplename
            let barcodeIdx = 0;
            const idxSample = headers.findIndex(h => h === 'sample' || h === 'samplename');
            if (idxSample !== -1) barcodeIdx = idxSample;

            // 孔位列:可能为 vialpos / vial position / 样品瓶
            const vialIdx = headers.findIndex(h =>
                h === 'vialpos' ||
                h === 'vial position' ||
                h === '样品瓶'
            );
            if (vialIdx === -1) {
                return { ok: false, msg: `未找到孔位列(VialPos / Vial position / 样品瓶),当前表头:${rawHeaders.join(' | ')}` };
            }

            const map = new Map();
            const rows = []; // ★ 新增：保留逐行信息，后续计算未用孔位集合要用

            for (let i = 1; i < lines.length; i++) {
                const cols = lines[i].split(delimiter);
                const barcode = (cols[barcodeIdx] || '').trim();
                const vialRaw = (cols[vialIdx] || '').trim();
                if (!barcode) continue;

                const vialClean = cleanVialPos(vialRaw);
                map.set(barcode, vialClean);

                rows.push({
                    barcode,
                    vialClean,
                });
            }

            // 增加未用孔位判断逻辑
            const unusedRows = rows.filter(r => {
                const barcode = (r.barcode || '').trim().toUpperCase();
                // ✅ 1. 条码包含 NOTUBE 关键词(而非精确匹配)
                if (barcode.includes('NOTUBE')) return true;
                // 2. 条码包含3个及以上的'-'
                const dashCount = (r.barcode || '').split('-').length - 1;
                if (dashCount >= 3) return true;
                return false;
            });

            return { ok: true, map, rows, unusedRows };
        }


        // ===== 新增：从后端加载 payload.json 并构建 sample -> barcode 映射 =====
        async function loadPayloadAndBuildSampleMap(onboardingFilename) {
            sampleToBarcode.clear(); // 清空旧映射

            if (!onboardingFilename) return { ok: false };

            try {
                const url = `{% url 'file_replace_get_payload' %}?filename=${encodeURIComponent(onboardingFilename)}`;
                const resp = await fetch(url, { method: 'GET' });

                if (!resp.ok) {
                    console.warn('未找到对应的 payload.json 文件');
                    return { ok: false };
                }

                const data = await resp.json();
                if (!data.ok || !data.payload) {
                    return { ok: false };
                }

                const payload = data.payload;
                const worksheetTable = payload.worksheet_table || [];

                // 遍历所有孔位，建立 match_sample -> origin_barcode 映射
                for (const row of worksheetTable) {
                    if (!Array.isArray(row)) continue;

                    for (const cell of row) {
                        const sample = (cell.match_sample || '').trim();
                        const barcode = (cell.origin_barcode || '').trim();

                        // 过滤无效数据
                        if (!sample || !barcode) continue;
                        if (sample === 'No match') continue;
                        if (barcode === 'NOTUBE' || barcode.includes('---')) continue;

                        // 正向映射：match_sample → origin_barcode
                        sampleToBarcode.set(sample, barcode);
                        sampleToBarcode.set(sample.toUpperCase(), barcode);

                        // ⭐ 反向映射：origin_barcode → match_sample（新增）
                        sampleToBarcode.set(barcode, sample);
                        sampleToBarcode.set(barcode.toUpperCase(), sample);

                    }
                }

                console.log(`✅ 已加载 payload.json，构建了 ${sampleToBarcode.size / 2} 个实验号映射`);
                return { ok: true, count: sampleToBarcode.size / 2 };

            } catch (e) {
                console.error('加载 payload.json 失败:', e);
                return { ok: false };
            }
        }


        // 新增：计算“未用孔位集合”的函数（核心逻辑）
        function computeUnusedVialPosSets(rows) {
            // 清空旧结果
            unusedVialPosKeys = new Set();
            unusedVialPosShow = [];

            // 1) 收集“实际出现”的孔位：只统计 1..96 / A1..H12
            const observedNums = new Set(); // 只放 1..96
            let minCol = 99;

            for (const r of rows) {
                const vial = (r.vialClean || '').toString().trim();
                if (!vial) continue;

                const norm = normalizeUserVialPosInput(vial); // 只认 1..96 / A1..H12
                if (!norm.ok) continue;

                // 只统计 1..96
                if (norm.num >= 1 && norm.num <= 96) {
                    observedNums.add(norm.num);
                    const col = ((norm.num - 1) % 12) + 1;
                    if (col < minCol) minCol = col;
                }
            }

            // 2) 推断取样起始列 startCol
            // - NIMBUS/Starlet：通常 minCol=1
            // - Tecan：若最小列号 > 1，则起始列 = minCol（你需求的逻辑）
            let startCol = 1;
            if (minCol >= 2 && minCol <= 12) startCol = minCol;

            // 3) 构造“应出现孔位集合”（1..96 中，列号 >= startCol）
            const expectedNums = new Set();
            for (let num = 1; num <= 96; num++) {
                const col = ((num - 1) % 12) + 1;
                if (col >= startCol) expectedNums.add(num);
            }

            // 4) 未用孔位 = expectedNums - observedNums （缺失的）
            const missingNums = [];
            for (const num of expectedNums) {
                if (!observedNums.has(num)) missingNums.push(num);
            }
            missingNums.sort((a, b) => a - b);

            // 5) 额外：如果存在 NOTUBE 行，且孔位在 expected 范围内，也应视为未用（可选，但通常符合直觉）
            // 注意：这不会把 >96 算进去，因为 normalizeUserVialPosInput 不认 >96
            for (const r of rows) {
                const barcode = (r.barcode || '').trim();
                const barcodeUpper = barcode.toUpperCase();

                // ✅ 判断是否为未用孔位的条码
                let isUnusedBarcode = false;

                // ✅ 条件1: 条码包含 'NOTUBE' 关键词(而非精确匹配)
                if (barcodeUpper.includes('NOTUBE')) {
                    isUnusedBarcode = true;
                }

                // 条件2: 条码包含3个及以上的 '-'
                if (!isUnusedBarcode) {
                    const dashCount = (barcode.match(/-/g) || []).length;
                    if (dashCount >= 3) {
                        isUnusedBarcode = true;
                    }
                }

                // 如果不是未用条码,跳过
                if (!isUnusedBarcode) continue;

                const vial = (r.vialClean || '').toString().trim();
                const norm = normalizeUserVialPosInput(vial);
                if (!norm.ok) continue;
                const col = ((norm.num - 1) % 12) + 1;
                if (col >= startCol) {
                    // 未用条码的孔位虽然"出现了",但按业务认为也应加入未用集合
                    if (!missingNums.includes(norm.num)) missingNums.push(norm.num);
                }
            }
            missingNums.sort((a, b) => a - b);

            // 6) 写入 unusedVialPosKeys / unusedVialPosShow
            // key 同时存 num 和 well，方便用户输入 84 或 H12 都能命中
            for (const num of missingNums) {
                const well = numToWell(num); // 需要你已有/新增的 numToWell
                unusedVialPosKeys.add(String(num));
                unusedVialPosKeys.add(well);
                unusedVialPosShow.push(`${well}(${num})`);
            }

            // 7) 更新 UI 摘要
            if (unusedVialPosShow.length > 0) {
                const preview = unusedVialPosShow.slice(0, 30).join('、');
                const more = unusedVialPosShow.length > 30 ? ` ...（还有 ${unusedVialPosShow.length - 30} 个）` : '';
                unusedSummaryEl.style.display = 'block';
                unusedSummaryEl.textContent = `起始列推断为第 ${startCol} 列；未用孔位（缺失）共 ${unusedVialPosShow.length} 个。示例：${preview}${more}`;
            } else {
                unusedSummaryEl.style.display = 'block';
                unusedSummaryEl.textContent = `起始列推断为第 ${startCol} 列；未检测到缺失孔位。`;
            }
        }


        // 上传文件后解析建立映射
        replaceFileInput.addEventListener('change', async (e) => {
            parsedOK = false;
            barcodeToVialPos = new Map();
            sampleToBarcode.clear(); // ✅ 清空旧映射

            const file = e.target.files && e.target.files[0];
            if (!file) {
                setAllowed(false, '请先选择需要替换的上机列表文件。');
                return;
            }

            const uploadedName = (file.name || '').trim();

            // ===== 解析项目名
            const proj = extractProjectFromFilename(uploadedName);
            projectNameInput.value = proj || '';

            // ✅ 1) 文件名必须在“文件下载页上机列表文件名集合”中
            if (!existingNames.has(uploadedName)) {
                setAllowed(false, `文件名不匹配：文件下载页未找到同名上机列表文件【${uploadedName}】；请确认文件名需完全一致。`);
                return;
            }

            // ✅ 通过文件名校验：允许后续操作（但替换逻辑仍需要解析成功）
            setAllowed(true, `文件名校验通过：已匹配到【${uploadedName}】`, false);

            // ✅ 2) 继续执行你原本的解析逻辑
            // ✅ 2) 使用正确的编码读取文件内容
            let text = '';
            try {
                // 尝试用 GBK 编码读取(中文 Excel/CSV 常用编码)
                const buffer = await file.arrayBuffer();
                const decoder = new TextDecoder('gbk');
                text = decoder.decode(buffer);
                console.log('✅ 使用 GBK 编码读取成功');
            } catch (e) {
                console.log('⚠️ GBK 读取失败,尝试 UTF-8:', e);
                try {
                    // 回退到 UTF-8
                    text = await file.text();
                    console.log('✅ 使用 UTF-8 编码读取成功');
                } catch (e2) {
                    alert('文件读取失败:' + e2.message);
                    setAllowed(false, '文件读取失败,无法继续。');
                    return;
                }
            }

            const res = parseOnboardingText(text);
            if (!res.ok) {
                alert('解析失败：' + res.msg);
                // 解析失败也要禁止后续（否则用户可以继续填并提交）
                setAllowed(false, '文件内容解析失败，无法继续。');
                return;
            }
            barcodeToVialPos = res.map;

            // ✅ 构建孔位 -> 条码/实验号（支持 A1 与 1 两类 key）
            vialPosToBarcode = new Map();
            for (const [barcode, vialClean] of barcodeToVialPos.entries()) {
                const cleaned = (vialClean || '').toString().trim();
                if (!cleaned) continue;

                // 1) 先记一份 raw key（兼容文件里就是 "A1" 或 "1" 的情况）
                vialPosToBarcode.set(cleaned.toUpperCase?.() ? cleaned.toUpperCase() : cleaned, barcode);

                // 2) 如果能归一化，则同时写两种 key："A1" 和 "1"
                const norm = normalizeUserVialPosInput(cleaned);
                if (norm.ok) {
                    vialPosToBarcode.set(norm.well, barcode);        // A1
                    vialPosToBarcode.set(String(norm.num), barcode); // 1
                }
            }

            // ✅ 构建未用孔位映射表
            unusedVialPosMap = new Map();
            if (res.unusedRows && res.unusedRows.length > 0) {
                for (const row of res.unusedRows) {
                    const vialClean = (row.vialClean || '').toString().trim();
                    if (!vialClean) continue;

                    const barcode = row.barcode || '';

                    // 写入多种key格式,方便匹配
                    unusedVialPosMap.set(vialClean.toUpperCase?.() ? vialClean.toUpperCase() : vialClean, barcode);

                    // 同时写入归一化后的 well 和 num 格式
                    const norm = normalizeUserVialPosInput(vialClean);
                    if (norm.ok) {
                        unusedVialPosMap.set(norm.well, barcode);        // A1
                        unusedVialPosMap.set(String(norm.num), barcode); // 1
                    }
                }
            }

            computeUnusedVialPosSets(res.rows || []);   // ★ 新增：算出未用孔位集合

            // ✅ 6) 新增：加载对应的 payload.json，构建 sample -> barcode 映射
            const payloadRes = await loadPayloadAndBuildSampleMap(uploadedName);
            if (payloadRes.ok) {
                console.log(`✅ 成功构建了 ${payloadRes.count} 个实验号映射`);
            } else {
                console.warn('⚠️ 未能加载 payload.json，用户将无法通过实验号匹配（仍可通过条码匹配）');
            }

            parsedOK = true;
            updateSubmitState();
        });

        // 根据用户选择的功能模块弹出不同的面板
        const replaceReasonSelect = document.getElementById('replace_reason');
        const usedPanel = document.getElementById('used-panel');
        const usedTbody = document.getElementById('used-tbody');

        const nousePanel = document.getElementById('nouse-panel');
        const nouseTbody = document.getElementById('nouse-tbody');

        const deletePanel = document.getElementById('delete-panel');
        const deleteTbody = document.getElementById('delete-tbody');

        // ===== 已用孔位替换（used）行 =====
        function createUsedRow() {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td>
                <input type="text"
                        class="form-control form-control-sm barcode-input used-vialpos-input"
                        name="used_vialpos[]"
                        placeholder="如 A1 / a1 / 1">
                <div class="vialpos-hint">孔位不在上机列表中</div>
                </td>

                <td>
                <input type="text"
                        class="form-control form-control-sm barcode-input used-old-input"
                        name="used_old_barcode[]"
                        placeholder="请输入当前条码或实验号">
                <div class="vialpos-hint used-old-hint">条码/实验号不在上机列表中</div>
                </td>

                <td>
                    <input type="text"
                        class="form-control form-control-sm barcode-input used-new-input"
                        name="used_new_barcode[]"
                        data-confirmed="false"
                        data-last-value=""
                        placeholder="请输入新条码或实验号">

                    <div class="vialpos-hint new-code-hint" style="display:none;">
                        <div class="hint-text"></div>
                        <div class="mt-1">
                            <button type="button" class="btn btn-sm btn-danger btn-confirm-replace">确认更换</button>
                            <button type="button" class="btn btn-sm btn-secondary btn-reinput">重新输入</button>
                        </div>
                    </div>
                </td>

                <td class="text-center">
                <div class="op-btns">
                    <button type="button" class="btn btn-outline-primary btn-sm btn-add">添加</button>
                    <button type="button" class="btn btn-outline-danger btn-sm btn-del">删除</button>
                </div>
                </td>
            `;

            const vialInput = tr.querySelector('.used-vialpos-input');
            const oldInput = tr.querySelector('.used-old-input');
            const vialHint = tr.querySelector('td:nth-child(1) .vialpos-hint');
            const oldHint = tr.querySelector('.used-old-hint');

            function clearError(el, hintEl) {
                el.classList.remove('vialpos-invalid');
                hintEl.classList.remove('show');
                updateSubmitState();
            }
            function setError(el, hintEl) {
                el.classList.add('vialpos-invalid');
                hintEl.classList.add('show');
                updateSubmitState();
            }

            function finalizeVialInputFormat() {
                const raw = vialInput.value.trim();
                if (!raw) return;

                const norm = normalizeUserVialPosInput(raw);
                if (!norm.ok) return; // 不合法不改写

                // ✅ 完成输入后才格式化
                vialInput.value = `${norm.well}(${norm.num})`;
            }


            // ===== A) 输入“当前条码/实验号” -> 匹配孔位 =====
            oldInput.addEventListener('input', async () => {
                const raw = (oldInput.value || '').trim();

                // 清理状态
                clearError(oldInput, oldHint);
                clearError(vialInput, vialHint);
                vialInput.value = '';

                if (!raw) return;
                if (!parsedOK) return;

                // ✅ 核心改造：支持条码 + 实验号双重查找
                const rawU = raw.toUpperCase();

                // 步骤1：直接用输入值查 origin_barcode（兼容大小写）
                let vialPosClean =
                    barcodeToVialPos.get(raw) ||
                    barcodeToVialPos.get(rawU);

                // ✅ 步骤2：【新增】如果仍未找到，尝试把输入当作 match_sample 查找
                if (!vialPosClean) {
                    const mappedBarcode =
                        sampleToBarcode.get(raw) ||
                        sampleToBarcode.get(rawU);

                    if (mappedBarcode) {
                        // 找到了对应的条码，再用条码查孔位
                        vialPosClean =
                            barcodeToVialPos.get(mappedBarcode) ||
                            barcodeToVialPos.get(mappedBarcode.toUpperCase());
                    }
                }

                // 步骤3：都找不到才报错
                if (!vialPosClean) {
                    setError(oldInput, oldHint);
                    return;
                }

                // 找到：反填孔位
                vialInput.value = formatVialPosDisplay(vialPosClean);

                // ✅ 新增: 检查反填的孔位是否为未用孔位
                const normVial = normalizeUserVialPosInput(vialPosClean);
                if (normVial.ok) {
                    const unusedBarcode =
                        unusedVialPosMap.get(normVial.well) ||
                        unusedVialPosMap.get(String(normVial.num));

                    if (unusedBarcode) {
                        vialHint.textContent = `该孔位为"未用孔位"(条码: ${unusedBarcode}),禁止在此模块替换`;
                        setError(vialInput, vialHint);
                        vialInput.classList.add('vialpos-invalid'); // 标红孔位框
                        return;
                    }
                }
            });


            // ===== B) 输入“孔位” -> 反查条码/实验号 =====
            vialInput.addEventListener('input', () => {
                const raw = vialInput.value.trim();

                // 清理状态
                clearError(vialInput, vialHint);
                clearError(oldInput, oldHint);
                oldInput.value = '';

                if (!raw) return;
                if (!parsedOK) return;

                // 用户输入归一化（支持 A1/a1 或 1..96）
                // ✅✅✅ 新增: 优先检查是否为未用孔位
                const norm = normalizeUserVialPosInput(raw);
                if (norm.ok) {
                    // 检查归一化后的 well 和 num 是否在未用孔位映射表中
                    const unusedBarcode =
                        unusedVialPosMap.get(norm.well) ||
                        unusedVialPosMap.get(String(norm.num));

                    if (unusedBarcode) {
                        vialHint.textContent = `该孔位为"未用孔位"(条码: ${unusedBarcode}),禁止在此模块替换`;
                        setError(vialInput, vialHint);
                        return; // 直接返回,阻止后续操作
                    }
                }

                if (!norm.ok) {
                    vialHint.textContent = '格式非法：允许 A1(1)/A1/a1/1';
                    setError(vialInput, vialHint);
                    return;
                }

                // ✅ 先把孔位框“统一渲染”为 A1(1) 形式（第4点要求）
                // vialInput.value = `${norm.well}(${norm.num})`;

                // 反查 key：优先 well、num
                const hit =
                    vialPosToBarcode.get(norm.well) ||
                    vialPosToBarcode.get(String(norm.num));

                if (!hit) {
                    vialHint.textContent = '孔位不在上机列表中';
                    setError(vialInput, vialHint);
                    return;
                }

                oldInput.value = hit;
            });

            vialInput.addEventListener('blur', finalizeVialInputFormat);
            vialInput.addEventListener('change', finalizeVialInputFormat);
            vialInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();       // 防止表单直接提交
                    finalizeVialInputFormat();
                }
            });

            // 添加：新增一行
            tr.querySelector('.btn-add').addEventListener('click', () => {
                usedTbody.appendChild(createUsedRow());
            });

            // 删除：删除当前行（至少保留 1 行）
            tr.querySelector('.btn-del').addEventListener('click', () => {
                if (usedTbody.children.length <= 1) return;
                tr.remove();
            });

            return tr;
        }


        // ===== 未用孔位替换（nouse）行 =====
        function createNouseRow() {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td>
                    <input type="text"
                        class="form-control form-control-sm barcode-input nouse-vialpos-input"
                        name="nouse_vialpos[]"
                        placeholder="请输入孔位（如 A1 / 1 / A1(1)）">
                    <div class="vialpos-hint nouse-vialpos-hint"> </div>
                </td>
                <td>
                    <input type="text"
                        class="form-control form-control-sm barcode-input nouse-new-input"
                        name="nouse_new_barcode[]"
                        data-confirmed="false"
                        data-last-value=""
                        placeholder="请输入新条码">

                    <div class="vialpos-hint new-code-hint" style="display:none;">
                        <div class="hint-text"></div>
                        <div class="mt-1">
                            <button type="button" class="btn btn-sm btn-danger btn-confirm-replace">确认更换</button>
                            <button type="button" class="btn btn-sm btn-secondary btn-reinput">重新输入</button>
                        </div>
                    </div>
                </td>
                <td class="text-center">
                    <div class="op-btns">
                        <button type="button" class="btn btn-outline-primary btn-sm btn-add">添加</button>
                        <button type="button" class="btn btn-outline-danger btn-sm btn-del">删除</button>
                    </div>
                </td>
            `;



            const vialInput = tr.querySelector('.nouse-vialpos-input');
            const hintEl = tr.querySelector('.nouse-vialpos-hint');

            function showHint(text, ok) {
                hintEl.textContent = text;
                hintEl.classList.add('show');
                hintEl.classList.toggle('ok', !!ok);
                hintEl.classList.toggle('err', !ok);
                vialInput.classList.toggle('vialpos-invalid', !ok);
                updateSubmitState();
            }
            function hideHint() {
                hintEl.textContent = '';
                hintEl.classList.remove('show', 'ok', 'err');
                vialInput.classList.remove('vialpos-invalid');
                updateSubmitState();
            }

            // ★ 即时提示：输入孔位时就判断是否为“未用孔位”
            vialInput.addEventListener('input', () => {
                const raw = vialInput.value.trim();
                if (!raw) {
                    hideHint();
                    return;
                }
                if (!parsedOK) {
                    showHint('请先上传并解析上机列表文件', false);
                    return;
                }

                // 允许 A1/a1/1/A1(1)
                const norm = normalizeUserVialPosInput(raw);
                let hit = false;

                if (norm.ok) {
                    // 用 well 或 num 去命中未用集合
                    hit = unusedVialPosKeys.has(norm.well) || unusedVialPosKeys.has(String(norm.num));
                } else {
                    // norm 不ok，用 raw 兜底
                    const k = raw.toUpperCase ? raw.toUpperCase() : raw;
                    hit = unusedVialPosKeys.has(k);
                }

                if (hit) {
                    showHint('✅ 该孔位识别为“未用孔位”，可以替换', true);
                } else {
                    showHint('❌ 该孔位未识别为“未用孔位”（可能是已用孔位或输入有误）', false);
                }
            });

            // 失焦时把输入规范化
            vialInput.addEventListener('blur', () => {
                const raw = vialInput.value.trim();
                if (!raw) return;

                const norm = normalizeUserVialPosInput(raw);
                if (!norm.ok) return;

                vialInput.value = `${norm.well}(${norm.num})`;
            });

            // 添加一行
            tr.querySelector('.btn-add').addEventListener('click', () => {
                nouseTbody.appendChild(createNouseRow());
            });

            // 删除当前行（至少保留 1 行）
            tr.querySelector('.btn-del').addEventListener('click', () => {
                if (nouseTbody.children.length <= 1) return;
                tr.remove();
            });

            return tr;
        }


        // ===== 孔位删除（delete）行 =====
        function createDeleteRow() {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td>
                    <input type="text"
                        class="form-control form-control-sm barcode-input delete-vialpos-input"
                        name="delete_vialpos[]"
                        placeholder="如 A1 / 1 / A1(1)">
                    <div class="vialpos-hint delete-vialpos-hint">孔位不在上机列表中</div>
                </td>

                <td>
                    <input type="text"
                        class="form-control form-control-sm barcode-input delete-code-input"
                        name="delete_barcode[]"
                        placeholder="请输入条码或实验号">
                    <div class="vialpos-hint delete-code-hint">条码/实验号不在上机列表中</div>
                </td>

                <td class="text-center">
                    <div class="op-btns">
                        <button type="button" class="btn btn-outline-primary btn-sm btn-add">添加</button>
                        <button type="button" class="btn btn-outline-danger btn-sm btn-del">删除</button>
                    </div>
                </td>
            `;

            const vialInput = tr.querySelector('.delete-vialpos-input');
            const codeInput = tr.querySelector('.delete-code-input');
            const vialHint = tr.querySelector('.delete-vialpos-hint');
            const codeHint = tr.querySelector('.delete-code-hint');

            function clearError(el, hintEl) {
                el.classList.remove('vialpos-invalid');
                hintEl.classList.remove('show');
                updateSubmitState();
            }
            function setError(el, hintEl, msg) {
                if (msg) hintEl.textContent = msg;
                el.classList.add('vialpos-invalid');
                hintEl.classList.add('show');
                updateSubmitState();
            }

            function finalizeVialInputFormat() {
                const raw = vialInput.value.trim();
                if (!raw) return;
                const norm = normalizeUserVialPosInput(raw);
                if (!norm.ok) return;
                vialInput.value = `${norm.well}(${norm.num})`;
            }

            // A) 输入条码/实验号 -> 匹配孔位（必须存在）
            codeInput.addEventListener('input', () => {
                const code = codeInput.value.trim();

                clearError(codeInput, codeHint);
                clearError(vialInput, vialHint);

                if (!code) return;

                if (!parsedOK) {
                    setError(codeInput, codeHint, '请先上传并解析上机列表文件');
                    return;
                }

                const vp = barcodeToVialPos.get(code);
                if (!vp) {
                    setError(codeInput, codeHint, '条码/实验号不在上机列表中');
                    return;
                }

                // 反填孔位
                vialInput.value = vp;
                finalizeVialInputFormat();
            });

            // B) 输入孔位 -> 匹配条码/实验号（必须存在）
            vialInput.addEventListener('input', () => {
                const raw = vialInput.value.trim();

                clearError(vialInput, vialHint);
                clearError(codeInput, codeHint);

                if (!raw) return;

                if (!parsedOK) {
                    setError(vialInput, vialHint, '请先上传并解析上机列表文件');
                    return;
                }

                const norm = normalizeUserVialPosInput(raw);
                if (!norm.ok) {
                    setError(vialInput, vialHint, '孔位格式不合法（如 A1 / 1 / A1(1)）');
                    return;
                }

                const hit =
                    vialPosToBarcode.get(norm.well) ||
                    vialPosToBarcode.get(String(norm.num));

                if (!hit) {
                    setError(vialInput, vialHint, '孔位不在上机列表中');
                    return;
                }

                codeInput.value = hit;
            });

            vialInput.addEventListener('blur', finalizeVialInputFormat);

            tr.querySelector('.btn-add').addEventListener('click', () => {
                deleteTbody.appendChild(createDeleteRow());
            });

            tr.querySelector('.btn-del').addEventListener('click', () => {
                if (deleteTbody.children.length <= 1) return;
                tr.remove();
            });

            return tr;
        }


        // ===== 根据 replace_reason 切换显示 =====
        // ✅ 新增：自定义模块的复选框引用
        const customSelectorPanel = document.getElementById('custom-selector-panel');
        const customUsedCheckbox = document.getElementById('custom-used');
        const customNouseCheckbox = document.getElementById('custom-nouse');
        const customDeleteCheckbox = document.getElementById('custom-delete');

        replaceReasonSelect.addEventListener('change', () => {
            const val = replaceReasonSelect.value;

            if (val === 'used') {
                customSelectorPanel.style.display = 'none';
                usedPanel.style.display = 'block';
                nousePanel.style.display = 'none';
                deletePanel.style.display = 'none';

                if (usedTbody.children.length === 0) {
                    usedTbody.appendChild(createUsedRow());
                }
            } else if (val === 'nouse') {
                customSelectorPanel.style.display = 'none';
                usedPanel.style.display = 'none';
                nousePanel.style.display = 'block';
                deletePanel.style.display = 'none';

                if (nouseTbody.children.length === 0) {
                    nouseTbody.appendChild(createNouseRow());
                }
            } else if (val === 'delete') {
                customSelectorPanel.style.display = 'none';
                usedPanel.style.display = 'none';
                nousePanel.style.display = 'none';
                deletePanel.style.display = 'block';

                if (deleteTbody.children.length === 0) {
                    deleteTbody.appendChild(createDeleteRow());
                }
            } else if (val === 'custom') {
                // ✅ 新增：显示自定义选择区域，初始隐藏所有功能面板
                customSelectorPanel.style.display = 'block';
                usedPanel.style.display = 'none';
                nousePanel.style.display = 'none';
                deletePanel.style.display = 'none';

                // 清空复选框状态
                customUsedCheckbox.checked = false;
                customNouseCheckbox.checked = false;
                customDeleteCheckbox.checked = false;
            } else {
                customSelectorPanel.style.display = 'none';
                usedPanel.style.display = 'none';
                nousePanel.style.display = 'none';
                deletePanel.style.display = 'none';
            }

            updateSubmitState();
        });


        // ✅ 新增：自定义模块的复选框变化事件
        function updateCustomPanels() {
            const isUsedChecked = customUsedCheckbox.checked;
            const isNouseChecked = customNouseCheckbox.checked;
            const isDeleteChecked = customDeleteCheckbox.checked;

            // 根据复选框状态显示/隐藏对应面板
            if (isUsedChecked) {
                usedPanel.style.display = 'block';
                if (usedTbody.children.length === 0) {
                    usedTbody.appendChild(createUsedRow());
                }
            } else {
                usedPanel.style.display = 'none';
                // 可选：清空表格内容
                // usedTbody.innerHTML = '';
            }

            if (isNouseChecked) {
                nousePanel.style.display = 'block';
                if (nouseTbody.children.length === 0) {
                    nouseTbody.appendChild(createNouseRow());
                }
            } else {
                nousePanel.style.display = 'none';
                // 可选：清空表格内容
                // nouseTbody.innerHTML = '';
            }

            if (isDeleteChecked) {
                deletePanel.style.display = 'block';
                if (deleteTbody.children.length === 0) {
                    deleteTbody.appendChild(createDeleteRow());
                }
            } else {
                deletePanel.style.display = 'none';
                // 可选：清空表格内容
                // deleteTbody.innerHTML = '';
            }

            updateSubmitState();
        }

        // 监听三个复选框的变化
        customUsedCheckbox.addEventListener('change', updateCustomPanels);
        customNouseCheckbox.addEventListener('change', updateCustomPanels);
        customDeleteCheckbox.addEventListener('change', updateCustomPanels);


        document.getElementById('replace-form').addEventListener('submit', (ev) => {
            if (submitBtn.disabled) {
                ev.preventDefault();
                alert('文件名未匹配或文件未解析成功，无法提交。');
            }
        });


        // === 新增：当日已取样过的条码/实验号集合 ===
        let sampledCodes = new Set();

        function normCode(v) {
            return (v || '').toString().trim().toUpperCase();
        }

        async function loadSampledCodes() {
            try {
                const resp = await fetch("{% url 'file_replace_sampled_codes' %}", { cache: "no-store" });
                if (!resp.ok) return;
                const data = await resp.json();
                const arr = data.codes || [];
                sampledCodes = new Set(arr.map(normCode).filter(Boolean));
            } catch (e) {
                // 拉取失败则不做限制（但后端仍会兜底校验）
                sampledCodes = new Set();
            }
        }

        function validateOneNewInput(inputEl) {
            const v = normCode(inputEl.value);
            const hint = inputEl.closest('td')?.querySelector('.new-code-hint');
            if (!hint) return true;

            const textEl = hint.querySelector('.hint-text');

            // 输入变更：只要用户改了内容，就视为“未确认”
            // （避免用户确认了A，后来改成B仍然被放行）
            if (inputEl.dataset.lastValue !== v) {
                inputEl.dataset.confirmed = 'false';
                inputEl.dataset.lastValue = v;
            }

            // 空值：隐藏提示，放行
            if (!v) {
                hint.style.display = 'none';
                if (textEl) textEl.textContent = '';
                inputEl.dataset.confirmed = 'false';
                return true;
            }

            // 命中重复：未确认 -> 显示确认条；已确认 -> 放行
            if (sampledCodes.has(v)) {
                if (inputEl.dataset.confirmed === 'true') {
                    hint.style.display = 'none';
                    return true;
                }
                if (textEl) textEl.textContent = '该条码/实验号今日已取样过，请确认是否继续替换。';
                hint.style.display = 'block';
                updateSubmitState();
                return false;
            }

            // 不重复：隐藏提示，放行
            hint.style.display = 'none';
            updateSubmitState();
            if (textEl) textEl.textContent = '';
            inputEl.dataset.confirmed = 'false';
            return true;
        }


        function validateAllNewInputs() {
            const inputs = Array.from(document.querySelectorAll('.used-new-input, .nouse-new-input'));

            for (const ipt of inputs) {
                const panel = ipt.closest('#used-panel, #nouse-panel');
                if (panel && panel.style.display === 'none') continue;

                const v = normCode(ipt.value);
                if (!v) continue;

                // 只拦截：重复 + 未确认
                if (sampledCodes.has(v) && ipt.dataset.confirmed !== 'true') {
                    // 触发一次显示提示（确保用户点提交时也能看到确认条）
                    validateOneNewInput(ipt);
                    return false;
                }
            }
            return true;
        }



        // 输入时即时校验（事件委托，兼容你动态 add row）
        (async () => {
            await loadSampledCodes();

            document.body.addEventListener('input', (e) => {
                const t = e.target;
                if (!t) return;

                // 移除 station 映射调用，仅保留验证逻辑
                if (t.classList.contains('used-new-input')) {
                    validateOneNewInput(t);
                    validateAllNewInputs();
                }

                if (t.classList.contains('nouse-new-input')) {
                    validateOneNewInput(t);
                    validateAllNewInputs();
                }
            });


            // ✅【新增】点击“确认更换”：标记该输入已确认，隐藏提示
            document.body.addEventListener('click', (e) => {
                const btn = e.target;
                if (!btn.classList.contains('btn-confirm-replace')) return;

                const hint = btn.closest('.new-code-hint');
                const input = hint?.closest('td')?.querySelector('input.used-new-input, input.nouse-new-input');
                if (!input) return;

                input.dataset.confirmed = 'true';
                hint.style.display = 'none';
                updateSubmitState();
            });

            // ✅【新增】点击“重新输入”：清空输入、取消确认、隐藏提示
            document.body.addEventListener('click', (e) => {
                const btn = e.target;
                if (!btn.classList.contains('btn-reinput')) return;

                const hint = btn.closest('.new-code-hint');
                const input = hint?.closest('td')?.querySelector('input.used-new-input, input.nouse-new-input');
                if (!input) return;

                input.value = '';
                input.dataset.confirmed = 'false';
                input.dataset.lastValue = '';
                hint.style.display = 'none';
                updateSubmitState();
                input.focus();
            });

            // 提交前兜底拦截（你模板里 form 的 id 是 replace-form）
            const form = document.getElementById('replace-form');
            if (form) {
                form.addEventListener('submit', (e) => {
                    const ok = validateAllNewInputs();
                    if (!ok) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });
            }
        })();

    });



</script>

{% endblock %}